
import { createStore } from 'vuex'
import startingPlatforms from '../models/platforms-all'
import settings from '../models/settings'
import { processPageJson, processBlockJson} from '../utilities/processing'

const store = createStore({
    state() {
        return {
            //Json from initial import; might not be needed. 
            initializedJsonString: '',

            // stores the complete JSON. All json elements should be access with getters,
            // rather then keeping separates properties for blocks etc. 
            currentPageJson: {},

            //json generated by block creator
            worksetArray: [],

            //template state
            platforms: startingPlatforms,
            platformsFilterArray: [],

            activePlatform: 'ALL',
            allBlockSettings: settings,

            //state for fotoscapes obj
            fotoscapeObject: {},
            contentLoaded: false,

            //state for savedpages
            pageDirectory: {}, 
        }

    },
    getters: {
        currentPageJsonToString(state) {
            return JSON.stringify(state.currentPageJson, (key, value) => {
                if (key === 'id') {
                    return '';
                }
                else return value
            }, "\t");
        },
        currentBlocksJson(state) {
            if (state.currentPageJson.blocks) {
                return state.currentPageJson.blocks;
            }
            else return []
        },
        currentWorkset(state) {
            return state.worksetArray;
        },
        platformsFilterArray(state) {
            let array = state.platformsFilterArray;
            return [...array]
        },
        activePlatform(state) {
            return state.activePlatform;
        },

        allPlatforms(state) {
            let products = Object.keys(state.platforms);

            let returnArray = [];

            for (let prod of products) {
                returnArray = returnArray.concat(state.platforms[prod]);
            }
            return returnArray;
        },
        contentLoadingStatus(state){
            return state.contentLoaded; 
        },
        pageDirectory(state){
            return state.pageDirectory; 
        }

    },
    mutations: {
        setFullJson(state, newJson) {
            const clone = JSON.parse(JSON.stringify(newJson));
            
            const filename = clone.filename; 
            state.currentPageJson = clone;
//this might be a hack, but the purpose is to make sure the page in the directory is the same in the workarea. 
            state.pageDirectory[filename]=clone; 
        },

        setBlocksJson(state, newBlocks) {
            state.currentPageJson.blocks = newBlocks;
        },
        setWorkset(state, newWorkset) {
            state.worksetArray = newWorkset;
        },
        mutateBlock(state, element){
            for (let block of state.worksetArray) {
                if (block.id === element.id) {
                    block = element;
                }
            }
            for (let block of state.currentPageJson.blocks) {
                if (block.id === element.id) {
                    block = element;
                }
            }

        },

        //payload includes id and block keys.
        replaceBlock(state, payload) {
            for (let block of state.worksetArray) {
                if (block.id === payload.id) {
                    block = payload.block;
                }
            }
            for (let block of state.currentPageJson.blocks) {
                if (block.id === payload.id) {
                    block = payload.block;
                }
            }
        },
        //Update block arrays
        pushToWorkset(state, processedBlock) {
            state.worksetArray.push(processedBlock);
        },
        pushToPlatformsFilterArray(state, platform) {
            state.platformsFilterArray.push(platform);
        },
        removeFromPlatformsFilterArray(state, platform) {
            state.platformsFilterArray = state.platformsFilterArray.filter(plat => plat != platform)
        },

        activatePlatform(state, platform) {
            state.activePlatform = platform;
        },

               // {
        //     payload:{
        //         name: string,
        //         json: Object
        //     }
        // }
        addPageToDirectory(state, payload){
            const pageName = payload.name; 
            const page = payload.json; 

            state.pageDirectory[pageName] = page; 
        },
        updateDirectory(state, payload){
            let json = payload.textContent; 
            if (typeof payload.textContent === 'string'){
                json = JSON.parse(payload.textContent)
            }
            let pageTitle = payload.filename;
            // console.log(typeof pageJson)
            state.pageDirectory[pageTitle]=json; 
            // console.log(JSON.stringify(state.pageDirectory[pageTitle]))
        },
        // let payload = {
        //     name: pageName,
        //     blocks: newValue, 
        // }
        mutateDirectoryPage(state, payload){
            state.pageDirectory[payload.name].blocks = payload.blocks; 
        },


        // const payload = {
        //     targetList: props.pageName, 
        //     updatedBlock: updatedBlock
        // }
        mutateListItem(state, payload){
            for (let block of state.pageDirectory[payload.targetList]['blocks']){
                if (block.id === payload.updatedBlock.id){
                    block = payload.updatedBlock; 
                }
            }
        },
                // const payload = {
        //     targetList: props.pageName,
        //     targetId: id
        // }
        deleteItembyId(state, payload){
            state.pageDirectory[payload.targetList].blocks = state.pageDirectory[payload.targetList]['blocks'].filter((item)=>item.id != payload.targetId); 
        }

    },
    actions: {
        submitPageJson(context, pageJson) {
            //Clean up platforms, fotoscape category, etc. before setting the pageJson in the store.
            let cleanPage = processPageJson(pageJson);

            context.commit('updateDirectory', cleanPage)

            context.commit('setFullJson', cleanPage);
            context.commit('setBlocksJson', cleanPage.blocks);
        },
        //payload includes id, block fields
        replaceBlock(context, payload) {
            context.commit('replaceBlock', payload);
        },

        updateBlock(context, payload){
            context.commit('mutateBlock', payload)
        },

        //takes block json, processes it, and pushes it to the workset
        createBlock(context, blockJson) {
            const processedBlock = processBlockJson(blockJson)
            context.commit('pushToWorkset', processedBlock);
        },

        //deleteBlock takes an id and filters all blockLists by that id.
        deleteBlock(context, id) {
            const updatedBlockList = context.getters.currentBlocksJson.filter(block => block.id != id);
            context.commit('setBlocksJson', updatedBlockList);
            const updatedWorkset = context.getters.currentWorkset.filter(block => block.id != id);


            context.commit('setWorkset', updatedWorkset);
        },


        //Template actions

        //Takes a string such as "cricket" as its payload and forwards it to the activatePlatform mutation.
        activatePlatform(context, platform) {
            context.commit('activatePlatform', platform)
        },


        //Used when removing a platform from TemplateBlockPlatforms to check whether platform being removed should also be removed from the platformsFilterArray
        checkFilterArray(context, platform) {
            for (let block of context.getters.currentBlocksJson) {
                if (block.platforms && block.platforms.includes(platform)) {
                    return
                }
                if (block.excludePlatforms && block.excludePlatforms.includes(platform)) {
                    return
                }
            }
            context.commit('removeFromPlatformsFilterArray', platform)
        },

        // {
        //     payload:{
        //         name: string,
        //         json: Object
        //     }
        // }
        addPageToDirectory(context, payload){
            const processedPage = processPageJson(payload.json)
            payload.json = processedPage; 

            context.commit('addPageToDirectory', payload)
        },
        loadPageFromDirectory(context, pageName){

            context.dispatch('submitPageJson', context.getters.pageDirectory[pageName])
        },
        // let payload = {
        //     name: pageName,
        //     blocks: newValue, 
        // }
        setBlocksOnPage(context, payload){
            context.commit('mutateDirectoryPage', payload); 
        },
        updateListItem(context, payload){
            context.commit('mutateListItem',payload)
        },
        // const payload = {
        //     targetList: props.pageName,
        //     targetId: id
        // }
        deleteListItem(context, payload){
            context.commit('deleteItembyId', payload)
        }

    }

}


);

export default store;

